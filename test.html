<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      .note-content {
        background-color: cadetblue;
        border-radius: 6px;
        min-height: 250px;
        margin-bottom: 20px;
        position: absolute;
        top: 60px !important;
        left: 50%;
        width: 640px;
        margin-left: -320px;
        transform: translate3d(0, 0, 0);
      }

      .note-content-mask {
        bottom: 0;
        left: 0;
        overflow: auto;
        position: fixed;
        right: 0;
        top: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1010;
        display: flex;
        justify-content: center;
        min-width: 1080px;
        line-height: 50px;
      }
    </style>
  </head>
  <body>
    <div class="note-content-mask">
      <div class="note-content">
        week 2 height-top offsetTop 为元素 top
        距离祖先元素的距离，若计算绝对到顶端的距离可以使用
        scollY+obj.getBoundingClientRect.Y(元素到窗口的高度) offsetHeight
        为元素高度包括 padding 和 border，也可直接用 height,scrollHeight
        若子元素大于父元素则为子元素的高度 innerHeight 为 窗口的高度 window 事件
        :page 鼠标到页面顶的坐标,包括卷入的高度,client 不包括 关键渲染路径
        style>layout>paint>composite
        应用中的元素样式>这些元素生成形状和位置——布局>每个元素填充像素>绘制这些图层
        故应该尽量用 transform 这样的不改变布局的属性； =100%?/ 最上级的
        100%为是视窗大小的 100% 绝对定位的 100%包括 padding
        大小，其他则只包括内容。（起始位置都从父元素的 content 左上角开始;若
        top:0,则从 border 开始,不包括 border 大小) 从头开始 debounce function
        debounce(func, wait = 20, immediate = true) { var timeout return
        function() { var context = this, args = arguments var later = function()
        { timeout = null if (!immediate) func.apply(context, args) } var callNow
        = immediate && !timeout clearTimeout(timeout) timeout =
        setTimeout(later, wait) if (callNow) func.apply(context, args) } }
        window.addEventListener("scroll", debounce(func))
        Q1：元素事件处理器所绑定的 handle 到底是什么？ A：handle =
        debounce(func),每次事件触发将执行的是 debounce 的 return ，即 function。
        Q2：如何每次都能取到 timeout? A: 通过闭包，每次调用 function 时，遇到
        timeout
        标识符若本函数内词法环境中没有，将根据该函数的[environment]中寻找(作用域链)，词法环境在函数创建时生成。
        debounce 作为声明，在全局中处理代码之前就应经解析创建注册。 ps:js
        中所有的标识符寻找都通过作用域链，即取决于变量函数写在哪个作用域内。如下：
        var a = function() { console.log(time) } function debounce1() { var time
        = 1 a() //not defined return function() { time = time + 1
        console.log(time) //2 a() //not defined } } debounce1()() Q3:
        timeout=seTtimeout() ，赋的是什么值？ A:
        赋值的是计时器ID，存在于浏览器中的全局变量，
        每执行一次setTimeout都会+1，代表该计时器的序号。clearTimeout将取消计时器，包括其中的回调函数，但不会回收其ID。
        Q4: 为什么要赋值 this？ A:因为 setTimeout
        为全局函数，是浏览器所处理，无论在哪里执行 this 都是全局。 Q5: immediate
        是什么？ A:immediate
        用来决定是否立即执行，即决定事件通过回调来执行还是通过判断 timeout
        来立即执行。当 immediate 为 true 则是判断
        timeout,故第一下就能立即执行，当为 false 时需成功完成等待事件才能回调。
        两种数据类型 基本数据类型 包括，string,null,undefine,boolean,number,
        存储内容，变量名与数据本身 存储位置，栈内存 引用数据类型
        包括，function,array,object 存储内容：变量名与属性的指针(地址)
        属性指针在栈内存，指针指向的内容在堆内存 PS: 栈与堆
        栈内存，有序存储，容量小但分配效率高，易于回收是一种向低地址扩展的数据结构，并且是连续的存储空间，所以栈顶和栈的最大容量是固定的
        栈与堆 栈与堆
        堆，是一种向高地址扩展的数据结构，并且是不连续的，因为系统采用的是链表的方式存放空闲存储块，当然是不连续的，链表的遍历方向是由低向高的，所以堆能够申请的空间的大小其实等同于整个系统的虚拟内存，只要还有内存空间，那么堆就能够不受限制的申请空间，这种方式比较灵活，申请空间也较大。
        js 的隐式转换 一元运算符 通过+、-字符串将转化为数字类型 var sNum = "20"
        alert(typeof sNum) //输出 "string" var iNum = -sNum alert(iNum) //输出
        "-20" alert(typeof iNum) //输出 "number" 加法计算
        若存在字符串将默认将其他元素转换为字符串进行拼接 var result = 5 + 5
        //两个数字 alert(result) //输出 "10" var result2 = 5 + "5"
        //一个数字和一个字符串 alert(result) //输出 "55" 正则
        默认将内容转换为字符串 let reg = new Reg("^[0-9a-z]+$", "gi") //
        reg.test(undefined) //返回true
      </div>
    </div>
  </body>
</html>

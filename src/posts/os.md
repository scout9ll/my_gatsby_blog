---
path: "/blog/os"
date: "2019-08-12"
title: "不同的操作系统带来了什么"
tags: ["计算机基础", "操作系统"]
---

### 前言

写了不少网页,也写了不少后端,但是每次都是傻瓜式的部署在 Netlify 和 Heroku 之类的服务器上,虽然他们的 CI(持续集成)非常方便,可是如果项目一扩大其费用不少,而且还是国外的服务器,在国内的访问也不会经常顺利.

因此,我开始考虑把项目移到国内的阿里云上.经查阅,由于操作系统的不一样,windows 的项目不能够简单的部署到 Linux 上的.

我不禁思考?不是所有的代码都会编译成最底层的二进制机器码吗?为什么不同操作系统就让它们无法互通?

为此,必须知道操作系统做了什么

### 操作系统的主要功能

#### 处理机管理功能

创建和撤销进程,进程的运行进行协调,进程之间的信息交换,按照算法把处理机分配给进程;

- 进程控制:多道程序环境下为了使作业能并发执行,必须为每道作业创建一个或几个进程,并为之分配必要的资源;  进程运行结束时,撤销该进程,以便及时回收;
- 进程同步:为了多个进程的运行进行协调,协调设置了进程同步机制;  常用的协调方式:  进程互斥方式;   进程同步方式 ;             实现进程同步时,最常用是信号量机制;
  进程通信,进程通信的任务实现相互合作进程之间的信息交换;
- 调度:   传统 OS 中,包括作业调度和进程调度;

#### 存储器管理功能

具有内存分配和回收功能,内存保护,地址映射,内存扩充功能;

- 内存分配:   主要任务:   为每道程序分配内存空间;     提高存储器利用率;   允许正在运行的程序申请附加内存空间;
- 内存保护:   确保用户程序在内存空间运行,互不干扰;     决不允许用户访问操作系统的程序和数据;
- 地址映射:  地址空间中的逻辑地址转换成内存空间与之对应的物理地址;
- 内存扩充:   并非物理上扩大内存容量,而是借助虚拟存储技术,逻辑上进行扩充;

#### 设备管理功能

完成用户提出的 I/O 请求,为进程分配需要的 I/O 设备;提高 cpu 和 I/O 设备的利用率;

- 缓冲管理:I/O 设备和 cpu 之间引入缓冲,有效缓和 I/O 设备和 cpu 速度不匹配的矛盾;提高了 cpu 的利用率,进而提高了系统吞吐量;
- 设备分配:根据用户的进程的 I/O 请求,系统现有资源情况以及某种设备分配策略,位置分配所需的设备;
- 设备处理: 又称为设备驱动程序,基本任务是用于实现 cpu 和设备控制器之间的通信,即由 cpu 向设备控制器发出 I/O 命令,完成指定操作;

#### 文件管理系统

具有对文件存储空间的管理,目录管理,文件读写管理,文件共享保护;

- 文件存储空间管理:为每个文件分配必要的外存空间,提高外存利用率,进而提高文件系统的存取速度;
- 目录管理:  为每个文件建立目录项,目录项包括文件名,文件属性,文件在磁盘上的物理位置;
- 文件读写管理:  根据用户请求,从外存读取数据,或将数据写入外存;读写操作不会同时进行,可合用一个读写指针;
- 文件保护:  防止系统文件被非法窃取和破坏,文件系统必须提供文件存取控制功能;

> 可见,操作系统实现了对所有重要硬件运行的代理,成为了程序运行的管家,是程序运行的环境.所以,执行同样的功能在不同的系统上就会有不同的执行方式.

### 文件在不同操作系统上的区别

一个可执行的二进制文件包含的不仅仅是机器指令，还包括各种数据、程序运行资源，机器指令只是其中的一部分。

#### 格式的不同

Windows 上大部分可执行文件为 PE 格式，Linux 里大部分可执行文件为 ELF 格式

#### 操作系统的 API 不同

一个可执行文件所执行的绝大多数操作（比如：文件操作、输入输出、内存申请释放、任务调度等等）都需要与操作系统交互才能完成，而不同的操作系统使用这些操作的方法完全不同，所以这个障碍更难跨越

### 总结

硬件需要操作系统为它们实现良好的相互运作,应用程序要在该系统上运行则必须服从操作系统的规定,所以应用在不同的系统上需要分别依据该操作系统的环境、接口编写不同的代码。

> ps:在为跨环境部署的麻烦苦恼时，我发现了 docker，一个为部署而生的虚拟运行容器，无论部署在哪里都使用同一个虚拟环境，解决了所有跨环境的问题！
